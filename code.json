"""
title: 🔧 SSH Server Agent
author: Teodor Gross
description: AI-powered SSH server management with interactive sessions
version: 1.3
requirements: paramiko, requests
Github: https://github.com/teodorgross/ssh-server-manager-openwebui
"""

import sqlite3
import json
import re
import hashlib
import base64
import threading
import queue
import signal
import os
from datetime import datetime, timedelta
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from concurrent.futures import ThreadPoolExecutor, TimeoutError as FutureTimeoutError

# Try import dependencies
try:
    import paramiko

    SSH_AVAILABLE = True
except ImportError:
    SSH_AVAILABLE = False

try:
    import requests

    HTTP_AVAILABLE = True
except ImportError:
    HTTP_AVAILABLE = False


class ServerConfig(BaseModel):
    name: str = Field(description="Server display name")
    host: str = Field(description="Server hostname or IP")
    username: str = Field(description="SSH username")
    password: str = Field(description="SSH password")
    model: str = Field(description="Ollama model to use")
    port: int = Field(default=22, description="SSH port")


class Pipe:
    class Valves(BaseModel):
        OLLAMA_BASE_URL: str = Field(
            default="http://localhost:11434/api/chat", description="Ollama API base URL"
        )
        SSH_TIMEOUT: int = Field(
            default=15, description="SSH connection timeout in seconds"
        )
        COMMAND_TIMEOUT: int = Field(
            default=30, description="Maximum command execution time in seconds"
        )
        MAX_CONCURRENT_COMMANDS: int = Field(
            default=3, description="Maximum concurrent SSH commands"
        )
        AUTO_EXECUTE_HIGH_CONFIDENCE: bool = Field(
            default=False,
            description="Automatically execute high-confidence AI commands",
        )
        ENABLE_FORCE_CLEANUP: bool = Field(
            default=True, description="Enable force cleanup of hanging sessions"
        )
        ENABLE_UPDATE_CHECK: bool = Field(
            default=True, description="Check for updates automatically on chat start"
        )
        # Server Configurations
        SERVERS: str = Field(
            default="""[
    {
        "name": "production",
        "host": "192.168.1.100",
        "username": "admin",
        "password": "your_password_here",
        "model": "llama3.2",
        "port": 22
    },
    {
        "name": "development",
        "host": "192.168.1.101",
        "username": "dev",
        "password": "dev_password_here",
        "model": "gemma2",
        "port": 22
    }
]""",
            description="JSON array of server configurations. Example structure provided above.",
        )

    def __init__(self):
        self.valves = self.Valves()
        self.db_file = "ssh_ollama_enhanced.db"
        self.active_sessions = {}
        self.last_interactive_command = {}  # Store interactive commands
        self.pending_interactive_sessions = {}  # Store active interactive sessions
        self.command_threads = {}  # Track running command threads
        self.thread_pool = ThreadPoolExecutor(max_workers=5)
        self.stop_flags = {}  # Flags to signal thread termination
        self.current_version = "1.3"  # Current version
        self.version_check_url = "https://raw.githubusercontent.com/teodorgross/ssh-server-manager-openwebui/refs/heads/main/version"
        self.github_url = "https://github.com/teodorgross/ssh-server-manager-openwebui"
        self.last_update_check = None
        self.latest_version_info = None
        self.init_database()
        self.session_passwords = {}
        self.server_configs = []
        self.load_server_configs()

    def load_server_configs(self):
        """Load server configurations from valves"""
        try:
            servers_json = self.valves.SERVERS.strip()
            if servers_json:
                self.server_configs = json.loads(servers_json)
                self.sync_servers_to_database()
        except json.JSONDecodeError as e:
            print(f"Error parsing server configurations: {e}")
            self.server_configs = []
        except Exception as e:
            print(f"Error loading server configurations: {e}")
            self.server_configs = []

    def sync_servers_to_database(self):
        """Sync server configurations from valves to database"""
        try:
            conn = sqlite3.connect(self.db_file)

            # Clear existing servers
            conn.execute("DELETE FROM servers")

            # Insert servers from valves
            for server in self.server_configs:
                server_id = server["name"].lower().replace(" ", "_").replace("-", "_")
                encrypted_password = self.encrypt_password(
                    server["password"], server_id
                )

                conn.execute(
                    """INSERT INTO servers 
                       (id, name, host, username, model, password_hash, port) 
                       VALUES (?, ?, ?, ?, ?, ?, ?)""",
                    (
                        server_id,
                        server["name"],
                        server["host"],
                        server["username"],
                        server["model"],
                        encrypted_password,
                        server.get("port", 22),
                    ),
                )

            conn.commit()
            conn.close()
            print(f"Synced {len(self.server_configs)} servers to database")

        except Exception as e:
            print(f"Error syncing servers to database: {e}")

    def check_for_updates(self, force_check: bool = False) -> Optional[Dict[str, Any]]:
        """Check for new version on GitHub"""
        if not self.valves.ENABLE_UPDATE_CHECK and not force_check:
            return None

        if not HTTP_AVAILABLE:
            return {
                "update_available": False,
                "error": "HTTP requests not available",
                "current_version": self.current_version,
                "checked_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            }

        # Always check on initialization, but respect minimum interval to avoid spam
        now = datetime.now()
        should_check = (
            force_check
            or not self.last_update_check
            or now - self.last_update_check >= timedelta(minutes=5)
        )  # Minimum 5 minutes between checks

        if not should_check and self.latest_version_info:
            return self.latest_version_info

        try:
            print("DEBUG: Checking for updates...")
            response = requests.get(self.version_check_url, timeout=5)
            response.raise_for_status()

            latest_version = response.text.strip()
            self.last_update_check = now

            # Compare versions
            if self.is_newer_version(latest_version, self.current_version):
                self.latest_version_info = {
                    "update_available": True,
                    "latest_version": latest_version,
                    "current_version": self.current_version,
                    "download_url": self.github_url,
                    "checked_at": now.strftime("%Y-%m-%d %H:%M:%S"),
                }
                print(f"DEBUG: Update available: {latest_version}")
            else:
                self.latest_version_info = {
                    "update_available": False,
                    "latest_version": latest_version,
                    "current_version": self.current_version,
                    "checked_at": now.strftime("%Y-%m-%d %H:%M:%S"),
                }
                print(
                    f"DEBUG: No update needed. Current: {self.current_version}, Latest: {latest_version}"
                )

            return self.latest_version_info

        except requests.exceptions.ConnectionError:
            error_info = {
                "update_available": False,
                "error": "No internet connection",
                "current_version": self.current_version,
                "checked_at": now.strftime("%Y-%m-%d %H:%M:%S"),
            }
            print("DEBUG: Update check failed - No internet connection")
            return error_info
        except requests.exceptions.Timeout:
            error_info = {
                "update_available": False,
                "error": "Connection timeout",
                "current_version": self.current_version,
                "checked_at": now.strftime("%Y-%m-%d %H:%M:%S"),
            }
            print("DEBUG: Update check failed - Timeout")
            return error_info
        except requests.exceptions.HTTPError as e:
            error_info = {
                "update_available": False,
                "error": f"Server error: {e.response.status_code}",
                "current_version": self.current_version,
                "checked_at": now.strftime("%Y-%m-%d %H:%M:%S"),
            }
            print(f"DEBUG: Update check failed - HTTP {e.response.status_code}")
            return error_info
        except Exception as e:
            error_info = {
                "update_available": False,
                "error": f"Check failed: {str(e)}",
                "current_version": self.current_version,
                "checked_at": now.strftime("%Y-%m-%d %H:%M:%S"),
            }
            print(f"DEBUG: Update check failed: {e}")
            return error_info

    def is_newer_version(self, latest: str, current: str) -> bool:
        """Compare version strings (supports X.Y format)"""
        try:

            def version_tuple(v):
                return tuple(map(int, v.split(".")))

            return version_tuple(latest) > version_tuple(current)
        except:
            # Fallback to string comparison
            return latest != current

    def get_update_notification(self) -> str:
        """Get update notification message"""
        update_info = self.check_for_updates()

        if not update_info:
            return ""

        # Handle errors
        if update_info.get("error"):
            return f"""⚠️ **UPDATE CHECK FAILED**

🔍 **Status:** {update_info['error']}
📅 **Checked:** {update_info['checked_at']}
📦 **Current Version:** {update_info['current_version']}

💡 **Note:** Update checks will retry automatically when connection is restored.

---"""

        # Handle updates available
        if update_info.get("update_available"):
            return f"""🚀 **NEW VERSION AVAILABLE!**

📦 **Current Version:** {update_info['current_version']}
✨ **Latest Version:** {update_info['latest_version']}
📅 **Checked:** {update_info['checked_at']}

🔗 **Download:** {update_info['download_url']}

💡 **To update:** Copy the latest code from GitHub and replace your current pipe.

---"""

        return ""

    def init_database(self):
        """Initialize SQLite database"""
        try:
            conn = sqlite3.connect(self.db_file)
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS servers (
                    id TEXT PRIMARY KEY,
                    name TEXT UNIQUE,
                    host TEXT,
                    username TEXT,
                    model TEXT,
                    password_hash TEXT,
                    port INTEGER DEFAULT 22,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_used TIMESTAMP
                )
            """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS command_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    server_id TEXT,
                    command TEXT,
                    ai_generated BOOLEAN,
                    confidence TEXT,
                    success BOOLEAN,
                    output TEXT,
                    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """
            )
            conn.commit()
            conn.close()
        except Exception as e:
            print(f"Database init error: {e}")

    def encrypt_password(self, password: str, server_id: str) -> str:
        """Simple password encryption"""
        encoded = base64.b64encode(password.encode()).decode()
        return encoded

    def decrypt_password(self, encrypted: str, server_id: str) -> str:
        """Decrypt password"""
        try:
            return base64.b64decode(encrypted.encode()).decode()
        except:
            return ""

    def pipes(self):

        try:
            # Reload server configs to get latest from valves
            self.load_server_configs()

            conn = sqlite3.connect(self.db_file)
            cursor = conn.execute(
                "SELECT id, name, host, username, model FROM servers ORDER BY name"
            )
            servers = cursor.fetchall()
            conn.close()

            models = [
                {"id": "ssh-manager", "name": "🔧 SSH Server Manager"},
            ]

            return models

        except Exception as e:
            return [{"id": "ssh-error", "name": f"❌ SSH Error: {str(e)}"}]

    def call_ollama(self, prompt: str, model: str) -> Optional[str]:
        """Call Ollama API"""
        try:
            payload = {
                "model": model,
                "messages": [{"role": "user", "content": prompt}],
                "stream": False,
            }

            if HTTP_AVAILABLE:
                response = requests.post(
                    self.valves.OLLAMA_BASE_URL, json=payload, timeout=30
                )
                response.raise_for_status()
                result = response.json()
                return result.get("message", {}).get("content", "")
            else:
                return "❌ HTTP requests not available"

        except Exception as e:
            return f"❌ Ollama API error: {e}"

    def execute_ssh_command_threaded(
        self,
        server_info: tuple,
        command: str,
        password: str = None,
        user_input: str = None,
        timeout: int = None,
    ) -> Dict[str, Any]:
        """
        Non-blocking SSH command execution for OpenWebUI
        Uses threading to prevent UI blocking
        """
        if not SSH_AVAILABLE:
            return {"success": False, "error": "SSH not available - install paramiko"}

        if timeout is None:
            timeout = self.valves.COMMAND_TIMEOUT

        server_id = server_info[0]
        session_key = f"{server_id}_{server_info[3]}_{server_info[2]}"

        # Create a stop flag for this command
        stop_flag = threading.Event()
        self.stop_flags[session_key] = stop_flag

        # Use thread pool to execute command
        try:
            future = self.thread_pool.submit(
                self._execute_ssh_command_worker,
                server_info,
                command,
                password,
                user_input,
                stop_flag,
            )

            # Wait with timeout - this allows OpenWebUI to remain responsive
            result = future.result(timeout=timeout)

            # Clean up
            if session_key in self.stop_flags:
                del self.stop_flags[session_key]

            return result

        except FutureTimeoutError:
            # Command timed out - try to stop gracefully
            stop_flag.set()

            # Force cleanup after short grace period
            try:
                future.result(timeout=2)  # Give 2 seconds for graceful shutdown
            except:
                pass

            self._force_cleanup_session(session_key)

            return {
                "success": False,
                "error": f"Command timed out after {timeout} seconds. Connection may be unstable.",
                "output": "Command was terminated due to timeout.",
                "exit_code": -1,
                "timeout": True,
            }

        except Exception as e:
            if session_key in self.stop_flags:
                del self.stop_flags[session_key]
            return {"success": False, "error": f"Execution error: {e}", "exit_code": -1}

    def _execute_ssh_command_worker(
        self,
        server_info: tuple,
        command: str,
        password: str,
        user_input: str,
        stop_flag: threading.Event,
    ) -> Dict[str, Any]:
        """
        Worker function that runs in separate thread
        Checks stop_flag regularly to allow graceful termination
        """
        try:
            server_id, name, host, username, model = server_info[:5]
            port = server_info[6] if len(server_info) > 6 else 22
            session_key = f"{server_id}_{username}_{host}"

            if not password:
                return {"success": False, "error": "No password provided"}

            # Check if we should stop before connecting
            if stop_flag.is_set():
                return {"success": False, "error": "Command cancelled"}

            # Check if we have a pending interactive session
            if (
                session_key in self.pending_interactive_sessions
                and user_input is not None
            ):
                return self.continue_interactive_session(
                    session_key, user_input, password, stop_flag
                )

            # Handle existing connections
            if session_key in self.active_sessions:
                client = self.active_sessions[session_key]
                try:
                    # Quick connection test
                    test_stdin, test_stdout, test_stderr = client.exec_command(
                        "echo test", timeout=3
                    )
                    test_stdout.channel.settimeout(3.0)
                    test_stdout.read()
                except:
                    del self.active_sessions[session_key]
                    client = None
            else:
                client = None

            # Create new connection if needed
            if not client:
                if stop_flag.is_set():
                    return {"success": False, "error": "Command cancelled"}

                client = paramiko.SSHClient()
                client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                client.connect(
                    hostname=host,
                    username=username,
                    password=password,
                    port=port,
                    timeout=self.valves.SSH_TIMEOUT,
                )
                self.active_sessions[session_key] = client
                self.session_passwords[session_key] = password

            # Check stop flag before executing
            if stop_flag.is_set():
                return {"success": False, "error": "Command cancelled"}

            # Execute command
            stdin, stdout, stderr = client.exec_command(command, get_pty=True)

            # Set timeouts to prevent hanging
            stdout.channel.settimeout(2.0)
            stderr.channel.settimeout(2.0)
            stdin.channel.settimeout(2.0)

            # Store the session for potential interactive continuation
            self.pending_interactive_sessions[session_key] = {
                "stdin": stdin,
                "stdout": stdout,
                "stderr": stderr,
                "command": command,
                "ssh_password": password,
            }

            # Handle user input
            if user_input is not None:
                try:
                    stdin.write(user_input + "\n")
                    stdin.flush()
                except Exception as e:
                    return {"success": False, "error": f"Failed to send input: {e}"}

            # SPECIAL HANDLING FOR IMMEDIATE INTERACTIVE COMMANDS
            if self.is_immediate_interactive_command(command) and user_input is None:
                import time

                command_lower = command.lower().strip()

                # Different wait times for different command types
                if command_lower in ["passwd", "sudo passwd"]:
                    time.sleep(0.3)  # Very short for passwd
                elif any(
                    cmd in command_lower
                    for cmd in ["mysql", "psql", "sqlite3", "python", "node", "irb"]
                ):
                    time.sleep(0.5)  # Short for interpreters/databases
                elif any(
                    cmd in command_lower for cmd in ["nano", "vim", "vi", "emacs"]
                ):
                    time.sleep(0.4)  # Short for editors
                else:
                    time.sleep(0.6)  # Default for other interactive commands

                # Check if command is still running (not finished)
                if not stdout.channel.exit_status_ready():
                    # Most interactive commands don't show output before waiting
                    return {
                        "success": False,
                        "interaction_required": True,
                        "output": self.get_interactive_startup_message(command),
                        "prompt_hint": self.extract_prompt_hint_for_command(
                            command, ""
                        ),
                        "command": command,
                        "timestamp": datetime.now().strftime("%H:%M:%S"),
                        "session_key": session_key,
                    }

            # Read output with regular stop flag checks
            import time

            full_output = ""
            error_output = ""
            sudo_password_sent = False
            password_filtered = False
            max_iterations = 100  # Prevent infinite loops
            iteration = 0

            while iteration < max_iterations:
                iteration += 1

                # Check if we should stop
                if stop_flag.is_set():
                    self._terminate_command(stdin, stdout, stderr)
                    return {
                        "success": False,
                        "error": "Command cancelled by user",
                        "output": full_output,
                    }

                # Check if command finished
                if stdout.channel.exit_status_ready():
                    if session_key in self.pending_interactive_sessions:
                        del self.pending_interactive_sessions[session_key]
                    break

                # Try to read data (non-blocking)
                try:
                    if stdout.channel.recv_ready():
                        chunk = stdout.channel.recv(4096).decode(
                            "utf-8", errors="ignore"
                        )

                        # Handle sudo password
                        if not sudo_password_sent and "sudo" in command.lower():
                            if any(
                                indicator in chunk.lower()
                                for indicator in ["[sudo]", "password for", "password:"]
                            ):
                                try:
                                    stdin.write(password + "\n")
                                    stdin.flush()
                                    sudo_password_sent = True
                                    time.sleep(0.5)
                                    continue
                                except:
                                    pass

                        # Handle sudo password filtering for display
                        if not password_filtered and "sudo" in command.lower():
                            if "[sudo]" in chunk or "password" in chunk.lower():
                                lines = chunk.split("\n")
                                filtered_chunk = ""
                                skip_line = False

                                for line in lines:
                                    if (
                                        "[sudo]" in line.lower()
                                        or "password for" in line.lower()
                                        or password in line
                                    ):
                                        skip_line = True
                                        continue
                                    else:
                                        if skip_line and line.strip():
                                            skip_line = False
                                        if not skip_line:
                                            filtered_chunk += line + "\n"

                                chunk = filtered_chunk
                                password_filtered = True

                        full_output += chunk

                except Exception:
                    pass  # Timeout or other non-fatal error

                # Small sleep to prevent CPU spinning, but check stop flag frequently
                for _ in range(3):  # 3 x 0.1 = 0.3 seconds total
                    if stop_flag.is_set():
                        break
                    time.sleep(0.1)

            # Check for interactive prompts
            if not stdout.channel.exit_status_ready():
                # Special case for commands that immediately wait for input
                if self.is_immediate_interactive_command(
                    command
                ) or self.looks_like_interactive_prompt(full_output):
                    return {
                        "success": False,
                        "interaction_required": True,
                        "output": (
                            full_output
                            if full_output
                            else f"Command '{command}' is waiting for input..."
                        ),
                        "prompt_hint": self.extract_prompt_hint_for_command(
                            command, full_output
                        ),
                        "command": command,
                        "timestamp": datetime.now().strftime("%H:%M:%S"),
                        "session_key": session_key,
                    }
                else:
                    # Force terminate the command to prevent hanging
                    try:
                        self._terminate_command(stdin, stdout, stderr)
                        if session_key in self.pending_interactive_sessions:
                            del self.pending_interactive_sessions[session_key]

                        return {
                            "success": False,
                            "error": "Command timed out and was forcefully terminated",
                            "output": full_output,
                            "exit_code": -1,
                            "timeout": True,
                        }
                    except Exception:
                        pass

            # Get remaining output and error (with timeout protection)
            try:
                stdout.channel.settimeout(2.0)
                remaining = stdout.read().decode("utf-8", errors="ignore")
                if remaining and not any(
                    skip in remaining for skip in [password, "[sudo]"]
                ):
                    full_output += remaining
            except:
                pass

            try:
                stderr.channel.settimeout(2.0)
                stderr_content = stderr.read().decode("utf-8", errors="ignore")
                if stderr_content:
                    if (
                        password not in stderr_content
                        and "[sudo]" not in stderr_content.lower()
                    ):
                        error_output = stderr_content
            except:
                pass

            # Get exit code
            try:
                stdout.channel.settimeout(2.0)
                exit_code = stdout.channel.recv_exit_status()
            except:
                exit_code = 0

            # Clean up completed session
            if session_key in self.pending_interactive_sessions:
                del self.pending_interactive_sessions[session_key]

            # Update server usage
            self.update_server_usage(server_id)

            # Clean output but preserve formatting and progress indicators
            clean_output = self.clean_but_preserve_formatting(full_output, password)

            return {
                "success": exit_code == 0,
                "output": clean_output,
                "error": error_output.strip(),
                "exit_code": exit_code,
                "timestamp": datetime.now().strftime("%H:%M:%S"),
                "is_streaming_cmd": self.is_streaming_command(command),
            }

        except paramiko.AuthenticationException:
            return {
                "success": False,
                "error": "Authentication failed - check credentials in valves",
                "exit_code": -1,
            }
        except paramiko.SSHException as e:
            return {"success": False, "error": f"SSH error: {e}", "exit_code": -1}
        except Exception as e:
            return {
                "success": False,
                "error": f"Connection error: {e}",
                "exit_code": -1,
            }

    def _terminate_command(self, stdin, stdout, stderr):
        """Gracefully terminate a running command"""
        try:
            # Send Ctrl+C
            stdin.write("\x03")
            stdin.flush()
            import time

            time.sleep(0.5)

            # Force close streams
            stdin.close()
            stdout.close()
            stderr.close()
        except:
            pass

    def _force_cleanup_session(self, session_key: str):
        """Force cleanup of a session"""
        try:
            # Clean up pending interactive sessions
            if session_key in self.pending_interactive_sessions:
                session = self.pending_interactive_sessions[session_key]
                try:
                    self._terminate_command(
                        session["stdin"], session["stdout"], session["stderr"]
                    )
                except:
                    pass
                del self.pending_interactive_sessions[session_key]

            # Clean up active sessions
            if session_key in self.active_sessions:
                try:
                    self.active_sessions[session_key].close()
                except:
                    pass
                del self.active_sessions[session_key]

            # Clean up session passwords
            if session_key in self.session_passwords:
                del self.session_passwords[session_key]

        except Exception as e:
            print(f"DEBUG: Force cleanup error: {e}")

    def cleanup_all_sessions(self):
        """Emergency cleanup - call this when OpenWebUI conversation is stopped"""
        print("DEBUG: Cleaning up all SSH sessions...")

        # Set all stop flags
        for stop_flag in self.stop_flags.values():
            stop_flag.set()

        # Force cleanup all sessions
        for session_key in list(self.active_sessions.keys()):
            self._force_cleanup_session(session_key)

        # Clear all tracking
        self.stop_flags.clear()
        self.active_sessions.clear()
        self.session_passwords.clear()
        self.pending_interactive_sessions.clear()
        self.last_interactive_command.clear()

    def execute_ssh_command(
        self,
        server_info: tuple,
        command: str,
        password: str = None,
        user_input: str = None,
    ) -> Dict[str, Any]:
        """Execute SSH command - uses threaded version with smart timeout handling"""
        command_lower = command.lower().strip()

        # Smart timeout based on command type
        if self.is_immediate_interactive_command(command) and user_input is None:
            # Interactive commands get shorter timeouts for faster detection
            if command_lower in ["passwd", "sudo passwd"]:
                timeout = 4  # Very short for passwd
            elif any(cmd in command_lower for cmd in ["mysql", "psql", "sqlite3"]):
                timeout = 6  # Short for databases
            elif any(cmd in command_lower for cmd in ["python", "node", "irb"]):
                timeout = 6  # Short for interpreters
            elif any(cmd in command_lower for cmd in ["nano", "vim", "vi", "emacs"]):
                timeout = 5  # Short for editors
            else:
                timeout = 8  # Default for other interactive

            return self.execute_ssh_command_threaded(
                server_info, command, password, user_input, timeout=timeout
            )
        else:
            # Normal commands get full timeout
            return self.execute_ssh_command_threaded(
                server_info,
                command,
                password,
                user_input,
                timeout=self.valves.COMMAND_TIMEOUT,
            )

    def continue_interactive_session(
        self,
        session_key: str,
        user_input: str,
        ssh_password: str,
        stop_flag: threading.Event = None,
    ) -> Dict[str, Any]:
        """Continue an existing interactive session with user input"""
        if session_key not in self.pending_interactive_sessions:
            return {"success": False, "error": "No pending interactive session found"}

        session_data = self.pending_interactive_sessions[session_key]
        stdin = session_data["stdin"]
        stdout = session_data["stdout"]
        stderr = session_data["stderr"]
        command = session_data["command"]

        try:
            # Send user input
            stdin.write(user_input + "\n")
            stdin.flush()

            import time

            full_output = ""
            wait_time = 0
            max_wait = 8

            # Read output after input
            while wait_time < max_wait:
                if stop_flag and stop_flag.is_set():
                    return {"success": False, "error": "Command cancelled"}

                if stdout.channel.recv_ready():
                    chunk = stdout.channel.recv(4096).decode("utf-8", errors="ignore")
                    # Filter out password echoes
                    if ssh_password not in chunk:
                        full_output += chunk
                    wait_time = 0

                # Check if command finished
                if stdout.channel.exit_status_ready():
                    # Command completed, clean up interactive session
                    del self.pending_interactive_sessions[session_key]
                    break

                time.sleep(0.2)
                wait_time += 0.2

            # If still running, check if it needs more input
            if not stdout.channel.exit_status_ready():
                if self.looks_like_interactive_prompt(full_output):
                    return {
                        "success": False,
                        "interaction_required": True,
                        "output": full_output,
                        "prompt_hint": self.extract_prompt_hint(full_output),
                        "command": command,
                        "timestamp": datetime.now().strftime("%H:%M:%S"),
                        "session_key": session_key,
                    }

            # Get remaining output and complete
            try:
                remaining = stdout.read().decode("utf-8", errors="ignore")
                if remaining and ssh_password not in remaining:
                    full_output += remaining
            except:
                pass

            # Get stderr
            error_output = ""
            try:
                stderr_content = stderr.read().decode("utf-8", errors="ignore")
                if stderr_content and ssh_password not in stderr_content:
                    error_output = stderr_content
            except:
                pass

            try:
                exit_code = stdout.channel.recv_exit_status()
            except:
                exit_code = 0

            # Clean up session
            if session_key in self.pending_interactive_sessions:
                del self.pending_interactive_sessions[session_key]

            return {
                "success": exit_code == 0,
                "output": self.clean_but_preserve_formatting(full_output, ssh_password),
                "error": error_output.strip(),
                "exit_code": exit_code,
                "timestamp": datetime.now().strftime("%H:%M:%S"),
                "continued_session": True,
            }

        except Exception as e:
            # Clean up on error
            if session_key in self.pending_interactive_sessions:
                del self.pending_interactive_sessions[session_key]
            return {"success": False, "error": f"Interactive session error: {e}"}

    def looks_like_interactive_prompt(self, output: str) -> bool:
        """Simple check if output looks like it's waiting for input"""
        if not output:
            return False

        # Check last few lines for common interactive patterns
        lines = output.strip().split("\n")
        last_lines = "\n".join(lines[-3:]).lower()

        interactive_indicators = [
            "[y/n]",
            "[yes/no]",
            "(y/n)",
            "(yes/no)",
            "password:",
            "enter",
            "input",
            "choose",
            "select",
            "continue?",
            "proceed?",
            "press",
            "type",
            "new password:",
            "retype new password:",
            "current password:",
            "changing password",
            ":",
            "?",
        ]

        return any(indicator in last_lines for indicator in interactive_indicators)

    def extract_prompt_hint(self, output: str) -> str:
        """Extract a simple hint about what the prompt is asking"""
        if not output:
            return "Interactive input needed"

        lines = output.strip().split("\n")
        last_line = lines[-1] if lines else ""

        # Common patterns
        if "[y/n]" in last_line.lower() or "[yes/no]" in last_line.lower():
            return "Expecting yes/no answer (y/n)"
        elif "password" in last_line.lower():
            return "Expecting password input"
        elif "enter" in last_line.lower():
            return "Expecting text input"
        elif any(word in last_line.lower() for word in ["choose", "select"]):
            return "Expecting menu selection (number)"
        else:
            return f"Prompt: {last_line[-100:]}"  # Show last part of the prompt

    def is_immediate_interactive_command(self, command: str) -> bool:
        """Check if command immediately waits for input without output"""
        immediate_interactive_commands = [
            # Password/User Management
            "passwd",
            "chpasswd",
            "usermod",
            "adduser",
            "useradd",
            "userdel",
            "su",
            "sudo su",
            "login",
            "newgrp",
            # Databases
            "mysql",
            "mysql -p",
            "psql",
            "sqlite3",
            "mongodb",
            "mongo",
            "redis-cli",
            "mariadb",
            "cockroach",
            "influx",
            "cassandra",
            "cqlsh",
            # Programming Languages & REPLs
            "python",
            "python3",
            "python2",
            "ipython",
            "ipython3",
            "node",
            "nodejs",
            "deno",
            "bun",
            "ruby",
            "irb",
            "pry",
            "php",
            "php -a",
            "perl",
            "perl -de1",
            "lua",
            "luajit",
            "julia",
            "octave",
            "matlab",
            "scala",
            "sbt",
            "amm",
            "clojure",
            "lein repl",
            "erlang",
            "erl",
            "elixir",
            "iex",
            "ghci",
            "hugs",
            "runhaskell",
            "go run",
            "gocomplete",
            "rustc",
            "cargo run",
            # Text Editors
            "nano",
            "vim",
            "vi",
            "nvim",
            "emacs",
            "joe",
            "micro",
            "helix",
            "pico",
            "mcedit",
            "ed",
            "ex",
            # File Viewers/Pagers
            "less",
            "more",
            "most",
            "bat",
            "cat -n",
            "nl",
            "head -f",
            "tail -f",
            "watch",
            # System Tools
            "fdisk",
            "cfdisk",
            "parted",
            "gparted",
            "gdisk",
            "mount",
            "umount",
            "fsck",
            "mkfs",
            "chroot",
            "systemctl edit",
            "visudo",
            "vipw",
            # Network & Remote
            "ssh",
            "scp",
            "sftp",
            "rsync",
            "telnet",
            "nc",
            "netcat",
            "ftp",
            "lftp",
            "curl -T",
            "wget --post-data",
            "openssl",
            "gpg",
            "ssh-keygen",
            # Development Tools
            "git rebase -i",
            "git commit",
            "git tag -a",
            "git merge",
            "docker exec -it",
            "docker run -it",
            "kubectl exec -it",
            "screen",
            "tmux",
            "byobu",
            "gdb",
            "lldb",
            "pdb",
            "ipdb",
            "npm init",
            "yarn init",
            "pip install -e",
            # Package Managers (interactive modes)
            "apt edit-sources",
            "dpkg-reconfigure",
            "debconf-set-selections",
            "yum shell",
            "dnf shell",
            "zypper shell",
            "pacman -S",
            "makepkg",
            "yay",
            "paru",
            # Configuration Tools
            "raspi-config",
            "nmtui",
            "bluetoothctl",
            "wpa_cli",
            "alsamixer",
            "nmcli connection edit",
            "systemd-analyze",
            "ufw",
            "iptables-restore",
            "fail2ban-client",
            # Monitoring & Process Management
            "top",
            "htop",
            "iotop",
            "iftop",
            "nethogs",
            "nload",
            "atop",
            "glances",
            "nmon",
            "dstat",
            "sar",
            "kill -STOP",
            "killall -STOP",
            # File Management
            "mc",
            "ranger",
            "nnn",
            "lf",
            "vifm",
            "fff",
            "find -exec",
            "xargs -p",
            "confirm",
            # Archive & Compression
            "tar -I",
            "zip -r",
            "unzip -l",
            "7z a",
            "rar a",
            # Backup & Sync
            "rsnapshot",
            "duplicity",
            "borg",
            "restic",
            "rclone config",
            "rclone mount",
            "syncthing",
            # Security & Encryption
            "openssl req",
            "openssl ca",
            "certbot",
            "acme.sh",
            "gpg --gen-key",
            "ssh-copy-id",
            "ssh-add",
            # Virtualization
            "virsh",
            "virt-manager",
            "vboxmanage",
            "vagrant",
            "lxc",
            "podman run -it",
            "nerdctl run -it",
            # Build Systems
            "make menuconfig",
            "cmake -i",
            "configure",
            "autoconf",
            "maven",
            "mvn",
            "gradle",
            "ant",
            "bazel",
            # Cloud & DevOps
            "ansible-playbook",
            "terraform plan",
            "helm install",
            "kubectl apply",
            "docker-compose up",
            "vagrant up",
            "aws configure",
            "gcloud auth",
            "az login",
            # System Recovery & Maintenance
            "fsck -i",
            "badblocks",
            "smartctl -t",
            "memtest86+",
            "rescue",
            "recovery",
            "chkdsk",
            "scandisk",
        ]

        command_lower = command.lower().strip()

        # Check for exact matches or command starts
        for cmd in immediate_interactive_commands:
            if command_lower == cmd or command_lower.startswith(cmd + " "):
                return True

        # Special patterns
        if any(
            pattern in command_lower
            for pattern in [
                "sudo passwd",
                "sudo su",
                "sudo -i",
                "sudo -s",
                "mysql -u",
                "psql -U",
                "sqlite3 ",
                "python -i",
                "python3 -i",
                "node -i",
                "vim +",
                "nano +",
                "emacs +",
                "ssh -t",
                "ssh -i",
                "ssh -X",
                "docker exec -it",
                "kubectl exec -it",
                "systemctl edit",
                "git commit -m",
                "openssl req -new",
                "gpg --encrypt",
            ]
        ):
            return True

        return False

    def get_interactive_startup_message(self, command: str) -> str:
        """Get appropriate startup message for interactive commands"""
        command_lower = command.lower().strip()

        # Password & User Management
        if any(cmd in command_lower for cmd in ["passwd", "chpasswd"]):
            return "Password change initiated - enter current password"
        elif any(cmd in command_lower for cmd in ["su", "sudo su", "login"]):
            return "User switch initiated - enter password"
        elif any(cmd in command_lower for cmd in ["adduser", "useradd", "usermod"]):
            return "User management tool started - follow prompts"

        # Databases
        elif "mysql" in command_lower or "mariadb" in command_lower:
            return "MySQL/MariaDB client started - ready for database connection"
        elif "psql" in command_lower:
            return "PostgreSQL client started - ready for database connection"
        elif "sqlite3" in command_lower:
            return "SQLite3 shell started - ready for SQL commands"
        elif any(cmd in command_lower for cmd in ["mongo", "mongodb", "redis-cli"]):
            return "Database client started - ready for commands"

        # Programming Languages
        elif any(cmd in command_lower for cmd in ["python", "ipython"]):
            return "Python interpreter started - ready for Python commands"
        elif command_lower in ["node", "nodejs", "deno", "bun"]:
            return "JavaScript runtime started - ready for JavaScript commands"
        elif any(cmd in command_lower for cmd in ["ruby", "irb", "pry"]):
            return "Ruby interpreter started - ready for Ruby commands"
        elif "php" in command_lower:
            return "PHP interpreter started - ready for PHP commands"
        elif any(
            cmd in command_lower for cmd in ["julia", "octave", "matlab", "scala"]
        ):
            return "Mathematical/Scientific interpreter started - ready for commands"

        # Text Editors
        elif command_lower in ["nano", "pico", "micro"]:
            return "Text editor opened - ready for editing"
        elif any(cmd in command_lower for cmd in ["vim", "vi", "nvim"]):
            return "Vim editor opened - press 'i' to insert, ':wq' to save and quit"
        elif "emacs" in command_lower:
            return "Emacs editor opened - Ctrl+X Ctrl+S to save, Ctrl+X Ctrl+C to quit"

        # File Viewers & Pagers
        elif any(cmd in command_lower for cmd in ["less", "more", "most"]):
            return "File pager opened - use arrow keys to navigate, 'q' to quit"
        elif any(cmd in command_lower for cmd in ["tail -f", "watch"]):
            return "Live monitoring started - Ctrl+C to stop"

        # System Tools
        elif any(cmd in command_lower for cmd in ["fdisk", "cfdisk", "parted"]):
            return "Disk partitioning tool started - be careful with changes!"
        elif "fsck" in command_lower:
            return "File system check started - follow prompts for repairs"
        elif "visudo" in command_lower:
            return "Sudo configuration editor opened - edit carefully!"

        # Network & Remote
        elif "ssh" in command_lower:
            return "SSH connection initiated - may require authentication"
        elif any(cmd in command_lower for cmd in ["telnet", "nc", "netcat"]):
            return "Network connection established - ready for communication"
        elif any(cmd in command_lower for cmd in ["ftp", "sftp", "lftp"]):
            return "File transfer client started - ready for file operations"

        # Development Tools
        elif any(
            cmd in command_lower for cmd in ["git commit", "git rebase", "git merge"]
        ):
            return "Git interactive operation started - follow prompts"
        elif any(cmd in command_lower for cmd in ["docker exec", "kubectl exec"]):
            return "Container shell started - ready for commands"
        elif any(cmd in command_lower for cmd in ["screen", "tmux", "byobu"]):
            return "Terminal multiplexer started - session management active"
        elif any(cmd in command_lower for cmd in ["gdb", "lldb", "pdb"]):
            return "Debugger started - ready for debugging commands"

        # Configuration Tools
        elif any(
            cmd in command_lower for cmd in ["nmtui", "bluetoothctl", "alsamixer"]
        ):
            return "System configuration tool started - use interface to configure"
        elif "raspi-config" in command_lower:
            return "Raspberry Pi configuration tool started"

        # Monitoring Tools
        elif any(cmd in command_lower for cmd in ["top", "htop", "iotop", "glances"]):
            return "System monitor started - real-time system information"
        elif any(cmd in command_lower for cmd in ["iftop", "nethogs", "nload"]):
            return "Network monitor started - real-time network information"

        # File Managers
        elif any(cmd in command_lower for cmd in ["mc", "ranger", "nnn", "vifm"]):
            return "File manager started - navigate with arrow keys"

        # Package Managers
        elif any(
            cmd in command_lower for cmd in ["apt edit-sources", "dpkg-reconfigure"]
        ):
            return "Package configuration tool started - follow prompts"
        elif any(
            cmd in command_lower for cmd in ["yum shell", "dnf shell", "zypper shell"]
        ):
            return "Package manager shell started - ready for package commands"

        # Cloud & DevOps
        elif any(
            cmd in command_lower for cmd in ["aws configure", "gcloud auth", "az login"]
        ):
            return "Cloud authentication started - follow login prompts"
        elif any(cmd in command_lower for cmd in ["terraform", "ansible", "helm"]):
            return "Infrastructure tool started - ready for operations"

        else:
            return f"Interactive command '{command}' started - ready for input"

    def extract_prompt_hint_for_command(self, command: str, output: str) -> str:
        """Extract prompt hint based on command and output"""
        command_lower = command.lower()

        # Password & User Management
        if "passwd" in command_lower:
            if not output or "current" in output.lower():
                return "Enter current password"
            elif "new" in output.lower():
                return "Enter new password"
            elif "retype" in output.lower() or "confirm" in output.lower():
                return "Confirm new password"
            else:
                return "Enter password"
        elif any(cmd in command_lower for cmd in ["su", "sudo su", "login"]):
            return "Enter password for user switch"

        # Databases
        elif "mysql" in command_lower or "mariadb" in command_lower:
            return "Enter MySQL commands (try: SHOW DATABASES; USE database_name;)"
        elif "psql" in command_lower:
            return "Enter PostgreSQL commands (try: \\l for databases, \\q to quit)"
        elif "sqlite3" in command_lower:
            return "Enter SQLite commands (try: .tables .schema .quit)"
        elif any(cmd in command_lower for cmd in ["mongo", "mongodb"]):
            return "Enter MongoDB commands (try: show dbs, use database)"
        elif "redis-cli" in command_lower:
            return "Enter Redis commands (try: KEYS *, GET key, SET key value)"

        # Programming Languages
        elif any(cmd in command_lower for cmd in ["python", "ipython"]):
            return "Enter Python code (try: print('hello'), help(), exit())"
        elif any(cmd in command_lower for cmd in ["node", "nodejs", "deno"]):
            return "Enter JavaScript code (try: console.log('hello'), .help, .exit)"
        elif any(cmd in command_lower for cmd in ["ruby", "irb", "pry"]):
            return "Enter Ruby code (try: puts 'hello', help, exit)"
        elif "php" in command_lower:
            return "Enter PHP code (try: echo 'hello'; exit;)"
        elif any(cmd in command_lower for cmd in ["julia", "octave", "matlab"]):
            return "Enter mathematical expressions or commands"

        # Text Editors
        elif command_lower in ["nano", "pico", "micro"]:
            return "Edit text - Ctrl+X to exit, Ctrl+O to save"
        elif any(cmd in command_lower for cmd in ["vim", "vi", "nvim"]):
            return "Vim: 'i' for insert mode, 'Esc' for command mode, ':wq' to save+quit, ':q!' to quit without saving"
        elif "emacs" in command_lower:
            return (
                "Emacs: Ctrl+X Ctrl+S to save, Ctrl+X Ctrl+C to quit, Ctrl+G to cancel"
            )

        # File Viewers & System Tools
        elif any(cmd in command_lower for cmd in ["less", "more", "most"]):
            return "Navigate: Arrow keys, Page Up/Down, 'q' to quit, '/' to search"
        elif any(cmd in command_lower for cmd in ["top", "htop"]):
            return "System monitor: 'q' to quit, 'k' to kill process, 'h' for help"
        elif any(cmd in command_lower for cmd in ["fdisk", "cfdisk"]):
            return (
                "Disk tool: Use menu options carefully! 'w' writes changes, 'q' quits"
            )
        elif "fsck" in command_lower:
            return "File system check: Answer 'y' to fix errors, 'n' to skip"

        # Network & Remote
        elif "ssh" in command_lower:
            return (
                "SSH: Enter password, accept host key (yes/no), or provide other auth"
            )
        elif any(cmd in command_lower for cmd in ["ftp", "sftp", "lftp"]):
            return "FTP: Use commands like 'ls', 'cd', 'get', 'put', 'quit'"
        elif any(cmd in command_lower for cmd in ["telnet", "nc", "netcat"]):
            return "Network connection: Type commands or data to send"

        # Development & Version Control
        elif "git commit" in command_lower:
            return "Git: Enter commit message, save and exit editor"
        elif "git rebase" in command_lower:
            return "Git rebase: Follow prompts, edit commits as needed"
        elif any(cmd in command_lower for cmd in ["docker exec", "kubectl exec"]):
            return "Container shell: Run commands inside container"
        elif any(cmd in command_lower for cmd in ["gdb", "lldb"]):
            return "Debugger: Try 'run', 'break main', 'continue', 'step', 'quit'"

        # Package Management
        elif "dpkg-reconfigure" in command_lower:
            return "Package reconfiguration: Follow prompts to configure package"
        elif any(cmd in command_lower for cmd in ["apt edit-sources", "visudo"]):
            return "System configuration: Edit carefully and save"

        # Configuration Tools
        elif any(cmd in command_lower for cmd in ["nmtui", "bluetoothctl"]):
            return "Configuration interface: Use arrow keys and Enter to navigate"
        elif "alsamixer" in command_lower:
            return (
                "Audio mixer: Arrow keys to navigate, 'M' to mute/unmute, 'Esc' to exit"
            )

        # File Managers
        elif any(cmd in command_lower for cmd in ["mc", "ranger", "nnn"]):
            return "File manager: Arrow keys to navigate, Enter to open, Tab to switch panel"

        # Cloud & DevOps
        elif any(cmd in command_lower for cmd in ["aws configure", "gcloud auth"]):
            return "Cloud setup: Enter credentials and configuration as prompted"
        elif "terraform" in command_lower:
            return "Terraform: Respond to prompts for infrastructure changes"

        else:
            # Fall back to output-based detection
            return self.extract_prompt_hint(output)

    def clean_but_preserve_formatting(self, output: str, password: str) -> str:
        """Clean output but preserve progress bars, percentages, and formatting"""
        if not output:
            return ""

        lines = output.split("\n")
        cleaned_lines = []

        for line in lines:
            # Skip password-related lines
            if password and password in line:
                continue
            if "[sudo]" in line.lower():
                continue
            if "password for" in line.lower():
                continue

            # Keep progress indicators, percentages, download info
            if any(
                indicator in line
                for indicator in [
                    "%",
                    "MB",
                    "KB",
                    "GB",
                    "Hit:",
                    "Get:",
                    "Ign:",
                    "Reading",
                    "Building",
                    "Downloading",
                    "Installing",
                    "Unpacking",
                ]
            ):
                cleaned_lines.append(line)
            # Keep regular output
            elif line.strip():
                cleaned_lines.append(line)

        return "\n".join(cleaned_lines)

    def is_streaming_command(self, command: str) -> bool:
        """Check if command typically produces streaming output"""
        streaming_patterns = [
            "apt",
            "yum",
            "dnf",
            "pacman",
            "pip",
            "npm",
            "yarn",
            "wget",
            "curl",
            "rsync",
            "scp",
            "git clone",
            "docker pull",
            "make",
            "compile",
            "build",
            "install",
            "update",
            "upgrade",
            "tar",
            "unzip",
            "cp",
            "mv",
            "dd",
        ]

        return any(pattern in command.lower() for pattern in streaming_patterns)

    def update_server_usage(self, server_id: str):
        """Update server last used timestamp"""
        try:
            conn = sqlite3.connect(self.db_file)
            conn.execute(
                "UPDATE servers SET last_used = CURRENT_TIMESTAMP WHERE id = ?",
                (server_id,),
            )
            conn.commit()
            conn.close()
        except:
            pass

    def get_server_info(self, model_id: str):
        """Get server information from model ID"""
        print(f"DEBUG: get_server_info called with model_id: '{model_id}'")

        if not model_id.startswith("ssh."):
            return None

        server_id = model_id[4:]  # Remove "ssh." prefix
        print(f"DEBUG: Looking for server_id: '{server_id}'")

        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.execute("SELECT * FROM servers WHERE id = ?", (server_id,))
            server = cursor.fetchone()
            conn.close()
            print(f"DEBUG: Found server: {server}")
            return server
        except Exception as e:
            print(f"DEBUG: Error in get_server_info: {e}")
            return None

    def save_command_history(
        self,
        server_id: str,
        command: str,
        ai_generated: bool,
        confidence: str,
        success: bool,
        output: str,
    ):
        """Save command to history"""
        try:
            conn = sqlite3.connect(self.db_file)
            conn.execute(
                """
                INSERT INTO command_history (server_id, command, ai_generated, confidence, success, output)
                VALUES (?, ?, ?, ?, ?, ?)
            """,
                (server_id, command, ai_generated, confidence, success, output),
            )
            conn.commit()
            conn.close()
        except:
            pass

    def pipe(self, body: dict, __user__: Optional[dict] = None) -> str:
        """Main pipe function"""
        model_id = body.get("model", "")
        messages = body.get("messages", [])

        if not messages:
            return "❌ No messages provided"

        last_message = messages[-1].get("content", "").strip()

        # Debug logging
        print(f"DEBUG: model_id = '{model_id}'")
        print(f"DEBUG: last_message = '{last_message}'")

        # Check if we're already connected to a server (by checking previous messages)
        server_context = self.get_server_context(messages)
        if server_context:
            print(f"DEBUG: Found server context: {server_context}")
            return self.handle_server_commands(last_message, server_context)

        # Check for direct SSH connection commands
        if last_message.lower().startswith("ssh ") or last_message.lower().startswith(
            "connect "
        ):
            return self.handle_direct_ssh_connection(last_message)

        # Route to appropriate handler
        if "ssh-manager" in model_id:
            return self.handle_manager_commands(last_message)
        elif "ssh." in model_id:
            server_info = self.get_server_info(model_id)
            if not server_info:
                return "❌ Server not found or not configured in valves"
            return self.handle_server_commands(last_message, server_info)
        else:
            # Default to manager
            return self.handle_manager_commands(last_message)

    def handle_direct_ssh_connection(self, command: str) -> str:
        """Handle direct SSH connection commands like 'ssh webserver' or 'connect production'"""
        try:
            # Parse command to get server name
            if command.lower().startswith("ssh "):
                server_name = command[4:].strip()
            elif command.lower().startswith("connect "):
                server_name = command[8:].strip()
            else:
                return "❌ Invalid SSH command format"

            if not server_name:
                return "❌ No server name specified"

            # Look for server in configured servers
            server_info = self.get_server_by_name(server_name)
            if not server_info:
                available_servers = [server["name"] for server in self.server_configs]
                if available_servers:
                    return f"""❌ **Server '{server_name}' not found**

**Available servers:**
{chr(10).join([f"- {name}" for name in available_servers])}

**Usage:** `ssh <server_name>` or `connect <server_name>`
**Example:** `ssh production`"""
                else:
                    return f"""❌ **Server '{server_name}' not found**

**No servers configured.** Please configure servers in the Valves settings first.

**Usage:** `ssh <server_name>` or `connect <server_name>`"""

            # Connect to the server
            return self.connect_to_server(server_info)

        except Exception as e:
            return f"❌ Error connecting to server: {e}"

    def get_server_context(self, messages: list) -> Optional[tuple]:
        """Check if we're in a server session by looking at conversation history"""
        # Look for the most recent connection or disconnection message
        for message in reversed(messages):
            content = message.get("content", "").strip()

            # If we find a disconnect message, we're NOT connected
            if "🔌 **Disconnected from" in content:
                return None

            # If we find a connection message, we ARE connected
            if "🟢 **Connected to" in content and "Current Session:" in content:
                # Extract server name from the connection message
                lines = content.split("\n")
                for line in lines:
                    if "Connected to" in line:
                        # Extract server name between "Connected to " and "**"
                        start = line.find("Connected to ") + 13
                        end = line.find("**", start)
                        if start > 12 and end > start:
                            server_name = line[start:end].strip()
                            return self.get_server_by_name(server_name)
        return None

    def get_server_by_name(self, server_name: str) -> Optional[tuple]:
        """Get server info by name"""
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.execute(
                "SELECT * FROM servers WHERE name = ? OR id = ?",
                (server_name, server_name),
            )
            server = cursor.fetchone()
            conn.close()
            return server
        except:
            return None

    def show_help(self) -> str:
        """Show help"""
        return """🔧 **SSH-Ollama Enhanced - Help**

## 🎯 **Interactive Commands**
- `/help` - Show this help
- `/status` - Show connection status
- `/history` - Show command history
- `/test` - Test SSH connection
- `$ ` - Execute command directly

## 🤖 **AI Features**
- Natural language: "install nginx", "check disk space"
- Auto sudo detection
- Safety validation

## 📝 **Examples**
- `install docker`
- `check memory usage`
- `$ ls -la`
- `/test`

💡 **Tip:** Use natural language for complex tasks!"""

    def handle_manager_commands(self, user_input: str) -> str:
        """Handle manager commands"""
        lower_input = user_input.lower()

        if any(keyword in lower_input for keyword in ["list", "show", "servers"]):
            return self.list_servers()
        elif "help" in lower_input:
            return self.show_manager_help()
        elif any(
            keyword in lower_input for keyword in ["check updates", "update", "version"]
        ):
            return self.show_update_status()
        else:
            return self.show_manager_welcome()

    def show_update_status(self) -> str:
        """Show current update status"""
        update_info = self.check_for_updates()

        if not update_info:
            return f"""🔍 **Update Check**

❌ **Unable to check for updates**
- Check your internet connection
- Ensure requests library is available

**Current Version:** {self.current_version}
**GitHub:** {self.github_url}"""

        if update_info.get("update_available"):
            return f"""🚀 **UPDATE AVAILABLE!**

📦 **Current Version:** {update_info['current_version']}
✨ **Latest Version:** {update_info['latest_version']}
📅 **Last Checked:** {update_info['checked_at']}

## 🔄 **How to Update:**
1. Visit: {update_info['download_url']}
2. Copy the latest code
3. Replace your current pipe
4. Save and reload

## 📋 **What's New:**
Check the repository for changelog and new features!

💡 **Tip:** Always backup your current configuration before updating."""
        else:
            return f"""✅ **YOU'RE UP TO DATE!**

📦 **Current Version:** {update_info['current_version']}
📅 **Last Checked:** {update_info['checked_at']}

🔍 **Automatic checks:** Every {self.valves.UPDATE_CHECK_INTERVAL} hours
⚙️ **Settings:** Update checks can be disabled in Valves

**GitHub:** {self.github_url}"""

    def list_servers(self) -> str:
        """List all configured servers from valves"""
        try:
            # Reload from valves to get current config
            self.load_server_configs()

            if not self.server_configs:
                return """📋 **No Servers Configured**

🚀 **To add servers:**
Edit the **SERVERS** setting in the valves and add your server configurations.

**Example:**
```json
[
    {
        "name": "production",
        "host": "192.168.1.100",
        "username": "admin",
        "password": "your_password_here",
        "model": "llama3.2",
        "port": 22
    }
]
```"""

            result = "📋 **Configured Servers:**\n\n"
            for server in self.server_configs:
                result += f"**🟢 {server['name']}**\n"
                result += f"  📍 Host: {server['host']}:{server.get('port', 22)}\n"
                result += f"  👤 User: {server['username']}\n"
                result += f"  🤖 Model: {server['model']}\n\n"

            result += "💡 **Usage:** `ssh <server_name>` or select from model dropdown"
            return result

        except Exception as e:
            return f"❌ Error listing servers: {e}"

    def show_manager_help(self) -> str:
        """Show manager help"""
        return f"""🔧 **SSH Server Manager - Help**

## 📋 **Server Management**
- `list servers` - Show configured servers
- `help` - Show this help
- `check updates` - Check for new versions

## 🔄 **Update System**
- **Automatic checks:** Every time chat is initiated
- **Manual check:** `check updates` or `version`
- **Current version:** {self.current_version}

💡 **Start by configuring servers in the Valves settings!**"""

    def show_manager_welcome(self) -> str:
        """Show welcome message with update notification and conditional content"""
        # Check for updates
        update_notification = self.get_update_notification()

        # Check if user has custom servers (not default configuration)
        has_custom_servers = self.has_custom_server_configuration()

        welcome_message = f"""{update_notification}

<sub>GitHub: https://github.com/teodorgross/ssh-server-manager-openwebui | Support: https://ko-fi.com/teodorgross | Version: {self.current_version}</sub>

---"""

        # Only show setup instructions if using default configuration
        if not has_custom_servers:
            welcome_message += """

## 🚀 **Quick Start**
1. **Configure servers:** Edit the **SERVERS** setting in the Valves
2. **List servers:** `list servers`
3. **Connect:** `ssh <server_name>` or select from model dropdown
4. **Execute commands:** Use natural language like "install nginx"

## 🔌 **Connection Methods**
- **Direct command:** `ssh production` or `connect webserver`
- **Model dropdown:** Select "🖥️ production (admin@192.168.1.100)"

## ⚙️ **Server Configuration via Valves**
Servers are configured directly in the pipe settings (Valves):

1. Open the pipe settings
2. Edit the **SERVERS** field  
3. Add your servers in JSON format
4. Save the settings

**JSON Format:**
```json
[
    {
        "name": "production",
        "host": "192.168.1.100",
        "username": "admin", 
        "password": "secure_password",
        "model": "llama3.2",
        "port": 22
    },
    {
        "name": "webserver",
        "host": "web.example.com",
        "username": "www-data",
        "password": "web_password",
        "model": "gemma2",
        "port": 2222
    }
]
```"""
        else:
            # Show simplified interface for users with custom configuration
            welcome_message += f"""

## 🎯 **Your Servers** ({len(self.server_configs)} configured)
- **List servers:** `list servers`
- **Connect:** `ssh <server_name>`
- **Manage:** Edit servers in Valves settings"""

        # Common commands section (always shown)
        welcome_message += """

## 🎯 **Available Commands**
- `ssh <server_name>` - Connect to a specific server
- `connect <server_name>` - Alternative connection command
- `list servers` - Show configured servers
- `help` - Show this help
- `check updates` - Check for new versions

## 📝 **Connection Examples**
- `ssh production`
- `connect webserver`
- `ssh development`

💡 **Tip:** After changing Valves settings, the configuration is automatically reloaded."""

        return welcome_message

    def has_custom_server_configuration(self) -> bool:
        """Check if user has configured custom servers (not default config)"""
        if not self.server_configs:
            return False

        # Check against exact default configuration structure
        default_servers = [
            {
                "name": "production",
                "host": "192.168.1.100",
                "username": "admin",
                "password": "your_password_here",
                "model": "llama3.2",
                "port": 22,
            },
            {
                "name": "development",
                "host": "192.168.1.101",
                "username": "dev",
                "password": "dev_password_here",
                "model": "gemma2",
                "port": 22,
            },
        ]

        # If number of servers is different, it's custom
        if len(self.server_configs) != len(default_servers):
            return True

        # Check each server against defaults
        for i, server in enumerate(self.server_configs):
            if i >= len(default_servers):
                return True

            default = default_servers[i]

            # Check key fields - if any are different, it's custom
            key_fields = ["name", "host", "username", "password", "model"]
            for field in key_fields:
                if server.get(field) != default.get(field):
                    return True

        # If we get here, it's still the default configuration
        return False

    def generate_ai_command(
        self, user_request: str, username: str, model: str
    ) -> Dict[str, Any]:
        """Generate AI command"""

        # Handle casual/greeting messages intelligently
        casual_patterns = [
            "was geht",
            "wie geht's",
            "hello",
            "hi",
            "hey",
            "what's up",
            "how are you",
            "wie läuft's",
            "alles klar",
            "sup",
            "yo",
        ]

        if any(pattern in user_request.lower() for pattern in casual_patterns):
            return {
                "command": "echo 'Hello! I am ready to help you manage this server. Try: check disk space, install software, show processes'",
                "confidence": "high",
                "explanation": "Friendly greeting response with helpful suggestions",
                "requires_sudo": False,
                "safety": "safe",
            }

        prompt = f"""You are an expert Linux system administrator. Generate a safe command for this request.

IMPORTANT INSTRUCTIONS:
- The user '{username}' is NOT root by default
- For commands that require sudo privileges, use the sudo prefix instead of adding sudo to the command
- Only use regular command if you're certain it doesn't need elevated privileges
- Be conservative: if unsure, use sudo prefix

User: {username}
Request: {user_request}

COMMAND FORMAT RULES:
- If command needs root privileges: use "sudo command"
- If command is safe for regular user: use "command" (without sudo)
- Examples of commands that typically need sudo: package installation, system service management, editing system files, mounting drives
- Examples of commands that use: ls, ps, df, cat (reading files), cd, grep, find (in user directories)

Respond with JSON only:
{{
    "command": "exact command with proper prefix (sudo or $ only)",
    "confidence": "high|medium|low",
    "explanation": "what this command does and why this privilege level",
    "requires_sudo": true/false,
    "safety": "safe|caution|dangerous"
}}

Examples:
- "check disk space": {{"command": "$ df -h", "confidence": "high", "explanation": "Shows disk usage - no privileges needed", "requires_sudo": false, "safety": "safe"}}
- "install nginx": {{"command": "sudo apt update && apt install -y nginx", "confidence": "high", "explanation": "Installs nginx web server - requires root privileges", "requires_sudo": true, "safety": "safe"}}
- "restart apache": {{"command": "sudo systemctl restart apache2", "confidence": "high", "explanation": "Restarts Apache service - requires root privileges", "requires_sudo": true, "safety": "safe"}}
- "list files": {{"command": "$ ls -la", "confidence": "high", "explanation": "Lists files in current directory - no privileges needed", "requires_sudo": false, "safety": "safe"}}

Return ONLY the JSON, no other text."""

        ai_response = self.call_ollama(prompt, model)
        if not ai_response or ai_response.startswith("❌"):
            return {"error": ai_response or "AI service unavailable"}

        try:
            json_match = re.search(r"\{.*\}", ai_response, re.DOTALL)
            if json_match:
                result = json.loads(json_match.group())
                if "command" not in result:
                    return {"error": "AI response missing command"}

                # Clean any remaining prefixes from the command
                command = result["command"].strip()
                if command.startswith("$ "):
                    command = command[2:]
                elif command.startswith("sudo "):
                    command = command[5:]

                result["command"] = command
                result.setdefault("confidence", "medium")
                result.setdefault("explanation", "")
                result.setdefault("requires_sudo", False)
                result.setdefault("safety", "caution")
                return result
            else:
                # Clean raw response too
                clean_command = ai_response.strip()
                if clean_command.startswith("$ "):
                    clean_command = clean_command[2:]
                elif clean_command.startswith("sudo "):
                    clean_command = clean_command[5:]

                return {
                    "command": clean_command,
                    "confidence": "low",
                    "explanation": "Raw AI response",
                    "requires_sudo": False,
                    "safety": "caution",
                }
        except json.JSONDecodeError:
            return {"error": "Failed to parse AI response"}

    def handle_server_commands(self, user_input: str, server_info: tuple) -> str:
        """Handle server commands"""
        if not SSH_AVAILABLE:
            return "❌ SSH not available. Install paramiko: `pip install paramiko`"

        server_id, name = server_info[0], server_info[1]

        # Check if this is a connection attempt
        if not self.is_server_connected(server_info):
            return self.connect_to_server(server_info)

        # Check if this is a retry with input for interactive command
        if user_input.startswith("!"):
            return self.retry_interactive_command(user_input[1:].strip(), server_info)

        # Handle slash commands
        if user_input.startswith("/"):
            return self.handle_slash_commands(user_input, server_info)

        # Handle direct commands
        if user_input.startswith("$"):
            command = user_input[1:].strip()
            if not command:
                return "❌ No command specified"
            return self.execute_direct_command(command, server_info)

        # Handle natural language
        return self.process_natural_language(user_input, server_info)

    def is_server_connected(self, server_info: tuple) -> bool:
        """Check if server is connected"""
        server_id, name, host, username = server_info[:4]
        session_key = f"{server_id}_{username}_{host}"
        return session_key in self.session_passwords

    def connect_to_server(self, server_info: tuple) -> str:
        """Auto-connect to server using valves configuration"""
        try:
            server_id, name, host, username, model, password_hash = server_info[:6]
            port = server_info[6] if len(server_info) > 6 else 22

            # Decrypt password from database
            password = self.decrypt_password(password_hash, server_id)

            if not password:
                return f"❌ **No password available for {name}**\n\nPlease check the server configuration in the Valves."

            # Test connection immediately
            result = self.execute_ssh_command(
                server_info, "echo 'Connected successfully'", password
            )

            if result["success"]:
                return f"""🟢 **Connected to {name}**

📍 **Server:** {host}:{port}
👤 **User:** {username}  
🤖 **Model:** {model}

## 🎯 **You can now use:**
- **Natural language:** `install nginx`, `check disk space`
- **Direct commands:** `$ ls -la`, `$ top`
- **Interactive:** `/help`, `/test`, `/status`, `/history`

💡 **Try:** `check system status` or `/test` to verify connection

🔧 **Current Session:** You are now in server mode for {name}. All commands will be processed for this server."""
            else:
                return f"❌ **Connection failed:** {result.get('error', 'Authentication failed')}\n\nPlease check the server configuration in the Valves."

        except Exception as e:
            return f"❌ Connection error: {e}"

    def retry_interactive_command(self, user_input: str, server_info: tuple) -> str:
        """Retry the last command with user input"""
        server_id = server_info[0]
        session_key = (
            f"{server_id}_{server_info[3]}_{server_info[2]}"  # server_id_username_host
        )

        # Get password from session
        if session_key not in self.session_passwords:
            return "❌ No active connection. Please connect first."

        password = self.session_passwords[session_key]

        # Try to continue existing interactive session first
        if session_key in self.pending_interactive_sessions:
            result = self.execute_ssh_command(server_info, "", password, user_input)
        elif server_id in self.last_interactive_command:
            # Fallback to old method
            last_cmd = self.last_interactive_command[server_id]
            result = self.execute_ssh_command(
                server_info, last_cmd, password, user_input
            )
        else:
            return "❌ No interactive command to retry. Run a command first."

        if result.get("interaction_required"):
            return f"""⌨️ **Still waiting for input on {server_info[1]}**

**Command:** `{result.get('command', 'Unknown')}`
**Previous Input:** `{user_input}`

**Current Output:**
```
{result['output']}
```

**Hint:** {result['prompt_hint']}

**Try again with:** `!your_response`"""

        # Clear the interactive command since it's completed
        if server_id in self.last_interactive_command:
            del self.last_interactive_command[server_id]

        # Save to history
        self.save_command_history(
            server_id,
            f"{result.get('command', 'Interactive command')} (with input: {user_input})",
            False,
            "interactive",
            result["success"],
            result.get("output", ""),
        )

        # Format normal response
        return self.format_command_result(
            result,
            result.get("command", "Interactive command"),
            server_info[1],
            user_input,
        )

    def format_command_result(
        self, result: dict, command: str, server_name: str, user_input: str = None
    ) -> str:
        """Format command execution result"""
        response = f"🖥️ **Command Execution on {server_name}**\n\n"
        response += f"**Command:** `{command}`\n"

        if user_input:
            response += f"**Input Provided:** `{user_input}`\n"

        response += f"**Timestamp:** {result.get('timestamp', 'Unknown')}\n\n"

        if result["success"]:
            response += "✅ **Success**\n\n"

            if result["output"]:
                output = result["output"]
                if len(output) > 2000:
                    response += f"```\n{output[:2000]}\n... (output truncated - {len(output)-2000} more characters)\n```"
                else:
                    response += f"```\n{output}\n```"
            else:
                response += "📝 Command executed successfully (no output)"
        else:
            response += "❌ **Failed**\n\n"
            if result["error"]:
                response += f"**Error Output:**\n```\n{result['error']}\n```"
            response += f"\n**Exit Code:** {result['exit_code']}"

        return response

    def handle_slash_commands(self, command: str, server_info: tuple) -> str:
        """Handle slash commands"""
        server_id, name = server_info[0], server_info[1]
        cmd_parts = command.split()
        base_cmd = cmd_parts[0].lower()

        if base_cmd == "/help":
            return f"""🎯 **Interactive Commands for {name}**

## 🔧 **Direct Execution**
- `$ ` - Execute command directly (bypass AI)
- `/direct ` - Same as $ prefix
- `/sudo ` - Execute with sudo privileges

## 📊 **Information & Control**
- `/status` - Show connection and server status
- `/history [n]` - Show last n commands (default 10)
- `/info` - Show detailed server information
- `/test` - Test SSH connection
- `/disconnect` - Disconnect from server and return to manager

## ⌨️ **Interactive Input (SIMPLE)**
- `!response` - Respond to interactive prompts
- **Examples:** `!yes`, `!1`, `!mypassword`

## 🤖 **AI Features**
- Natural language: "install nginx", "check memory usage"
- AI generates appropriate commands with explanations
- Automatic sudo detection and password handling
- Safety validation for dangerous commands

## 📝 **Examples**
```bash
# Natural language AI commands
install docker
check disk space
update system packages
show running processes

# Direct command execution
$ ls -la /home
$ top
$ df -h

# Interactive commands
/sudo systemctl restart nginx
/history 5
/test
/disconnect

# Interactive input handling (SIMPLE!)
$ sudo apt install something
# (when prompted for Y/n)
!y

$ nano config.txt
# (when nano opens and waits for content)
!This is my config content
```

## 🔄 **Session Management**
- `/disconnect` - End current SSH session and return to server manager

## ⌨️ **Interactive Commands Workflow (SIMPLE)**
1. Run a command: `$ nano config.txt`
2. If it waits for input, you'll see: "Interactive Input Required"
3. Respond with: `!your_response_here` (NO SPACES after !)
4. Continue until command completes

💡 **Much easier:** Just use `!` instead of complex commands!"""

        elif base_cmd == "/test":
            return self.test_connection(server_info)

        elif base_cmd == "/status":
            return self.show_server_status(server_info)

        elif base_cmd == "/history":
            limit = 10
            if len(cmd_parts) > 1:
                try:
                    limit = int(cmd_parts[1])
                    limit = max(1, min(limit, 50))
                except ValueError:
                    limit = 10
            return self.show_history(server_id, limit)

        elif base_cmd == "/info":
            return self.show_server_info_detailed(server_info)

        elif base_cmd == "/disconnect":
            return self.disconnect_from_server(server_info)

        elif base_cmd in ["/direct", "/sudo"]:
            if len(cmd_parts) < 2:
                return f"❌ Usage: `{base_cmd} <command>`"

            actual_command = " ".join(cmd_parts[1:])
            if base_cmd == "/sudo" and not actual_command.startswith("sudo"):
                actual_command = f"sudo {actual_command}"

            return self.execute_direct_command(actual_command, server_info)

        else:
            return f"""❌ **Unknown command:** `{command}`

Type `/help` to see all available commands.

**Quick commands:**
- `/status` - Connection status
- `/test` - Test SSH connection  
- `/disconnect` - End session
- `/help` - Full command list

**Interactive input:**
- `!response` - Reply to prompts (much simpler!)"""

    def test_connection(self, server_info: tuple) -> str:
        """Test SSH connection"""
        server_id, name, host, username, model, password_hash = server_info[:6]
        session_key = f"{server_id}_{username}_{host}"

        if session_key not in self.session_passwords:
            password = self.decrypt_password(password_hash, server_id)
        else:
            password = self.session_passwords[session_key]

        if not password:
            return f"❌ No password available for {name}"

        try:
            result = self.execute_ssh_command(
                server_info, "echo 'SSH test successful'", password
            )

            if result["success"]:
                return f"✅ **SSH Connection Test Successful**\n\nServer: {name} ({host})\nOutput: {result.get('output', 'No output')}"
            else:
                return f"❌ **SSH Connection Test Failed**\n\nServer: {name} ({host})\nError: {result.get('error', 'Unknown error')}"

        except Exception as e:
            return f"❌ Connection test failed: {e}"

    def show_server_status(self, server_info: tuple) -> str:
        """Show server status"""
        server_id, name, host, username, model = server_info[:5]
        port = server_info[6] if len(server_info) > 6 else 22
        session_key = f"{server_id}_{username}_{host}"
        is_connected = session_key in self.active_sessions

        connection_status = "🟢 Connected" if is_connected else "🟡 Not Connected"

        return f"""📊 **Server Status: {name}**

## 🔗 **Connection**
- Status: {connection_status}
- Host: {host}:{port}
- Username: {username}

## 🤖 **AI Configuration**
- Model: {model}
- Auto Execute: {'✅' if self.valves.AUTO_EXECUTE_HIGH_CONFIDENCE else '❌'}

## ⚙️ **Configuration**
- SSH Timeout: {self.valves.SSH_TIMEOUT}s
- Command Timeout: {self.valves.COMMAND_TIMEOUT}s
- Ollama URL: {self.valves.OLLAMA_BASE_URL}

💡 **Ready for commands!**"""

    def show_history(self, server_id: str, limit: int = 10) -> str:
        """Show command history"""
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.execute(
                """
                SELECT command, ai_generated, confidence, success, executed_at
                FROM command_history 
                WHERE server_id = ? 
                ORDER BY executed_at DESC 
                LIMIT ?
            """,
                (server_id, limit),
            )

            history = cursor.fetchall()
            conn.close()

            if not history:
                return "📝 **No command history found**"

            result = f"📝 **Command History (Last {limit})**\n\n"
            for i, (
                command,
                ai_generated,
                confidence,
                success,
                executed_at,
            ) in enumerate(history, 1):
                source_icon = "🤖" if ai_generated else "💻"
                status_icon = "✅" if success else "❌"
                result += f"**{i}.** {source_icon} {status_icon} `{command}`\n"
                result += f"    📅 {executed_at}\n\n"

            return result

        except Exception as e:
            return f"❌ Error retrieving history: {e}"

    def show_server_info_detailed(self, server_info: tuple) -> str:
        """Show detailed server information"""
        server_id, name, host, username, model = server_info[:5]
        port = server_info[6] if len(server_info) > 6 else 22
        session_key = f"{server_id}_{username}_{host}"
        is_connected = session_key in self.active_sessions

        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.execute(
                "SELECT created_at, last_used FROM servers WHERE id = ?", (server_id,)
            )
            dates = cursor.fetchone()
            conn.close()

            created_at = dates[0] if dates else "Unknown"
            last_used = dates[1] if dates and dates[1] else "Never"

        except:
            created_at = "Unknown"
            last_used = "Unknown"

        connection_status = "🟢 Active" if is_connected else "🔴 Inactive"

        return f"""📋 **Detailed Server Information**

## 🏷️ **Identity**
- **Name:** {name}
- **Server ID:** {server_id}
- **Host:** {host}:{port}
- **Username:** {username}

## 🔗 **Connection**
- **Status:** {connection_status}
- **SSH Timeout:** {self.valves.SSH_TIMEOUT}s
- **Command Timeout:** {self.valves.COMMAND_TIMEOUT}s

## 🤖 **AI Configuration**
- **Model:** {model}
- **Ollama URL:** {self.valves.OLLAMA_BASE_URL}
- **Auto Execute:** {'Enabled' if self.valves.AUTO_EXECUTE_HIGH_CONFIDENCE else 'Disabled'}

## 📅 **Usage History**
- **Created:** {created_at}
- **Last Used:** {last_used}

## 🛠️ **Available Actions**
- `/test` - Test connection
- `/history` - View command history
- `/disconnect` - End session
"""

    def disconnect_from_server(self, server_info: tuple) -> str:
        """Disconnect from current server session"""
        server_id, name, host, username = server_info[:4]
        session_key = f"{server_id}_{username}_{host}"

        try:
            # Close SSH connection if active
            if session_key in self.active_sessions:
                try:
                    self.active_sessions[session_key].close()
                except:
                    pass
                del self.active_sessions[session_key]

            # Clean up session password
            if session_key in self.session_passwords:
                del self.session_passwords[session_key]

            # Clean up any pending interactive sessions
            if session_key in self.pending_interactive_sessions:
                del self.pending_interactive_sessions[session_key]

            # Clean up interactive commands
            if server_id in self.last_interactive_command:
                del self.last_interactive_command[server_id]

            return f"""🔌 **Disconnected from {name}**

✅ **Session terminated successfully!**

You are now back in **SSH Manager mode**. The chat context has been reset.

## 🎯 **What you can do now:**
- **View servers:** `list servers`
- **Connect directly:** `ssh <server_name>`
- **Get help:** `help`
- **Reconnect:** Select a server from the model dropdown

## 🔄 **To reconnect to {name}:**
1. Type: `ssh {name}` or select **🖥️ {name}** from the model dropdown

💡 **Tip:** Your next message will be processed by the SSH Manager, not the server."""

        except Exception as e:
            return f"❌ Error disconnecting: {e}"

    def execute_direct_command(self, command: str, server_info: tuple) -> str:
        """Execute direct command with simple interactive support"""
        server_id, name = server_info[0], server_info[1]

        if not command.strip():
            return "❌ Empty command"

        # Security check
        dangerous_patterns = [r"rm\s+-rf\s+/", r"dd\s+if=.*of=/dev/", r"mkfs\."]
        for pattern in dangerous_patterns:
            if re.search(pattern, command, re.IGNORECASE):
                return f"⚠️ **Dangerous command blocked:** `{command}`\nUse AI assistant for safer alternatives"

        # Get session password
        session_key = (
            f"{server_id}_{server_info[3]}_{server_info[2]}"  # server_id_username_host
        )
        if session_key not in self.session_passwords:
            return f"❌ **No active connection to {name}**\n\nPlease connect first: `ssh {name}`"

        password = self.session_passwords[session_key]

        try:
            result = self.execute_ssh_command(server_info, command, password)

            # Handle interactive prompts
            if result.get("interaction_required"):
                # Store the command for later retry
                self.last_interactive_command[server_id] = command

                return f"""⌨️ **Interactive Input Required on {name}**

**Command:** `{command}`

**Current Output:**
```
{result['output']}
```

**Hint:** {result['prompt_hint']}

🎯 **The command is waiting for your input!**

**How to respond:**
`!YOUR_RESPONSE_HERE`

**Examples:**
- `!yes` (for yes/no questions)
- `!1` (for menu selections)  
- `!mypassword` (for password prompts)
- `!/path/to/file` (for file paths)

💡 **Much simpler:** Just type `!` followed by your response!"""

            # Normal command completion
            self.save_command_history(
                server_id,
                command,
                False,
                "direct",
                result["success"],
                result.get("output", ""),
            )
            return self.format_command_result(result, command, name)

        except Exception as e:
            return f"❌ Command execution failed: {e}"

    def process_natural_language(self, user_input: str, server_info: tuple) -> str:
        """Process natural language through AI"""
        server_id, name, host, username, model = server_info[:5]
        session_key = f"{server_id}_{username}_{host}"

        # Check if we have an active session with password
        if session_key not in self.session_passwords:
            return f"❌ **No active connection to {name}**\n\nPlease connect first: `ssh {name}`"

        password = self.session_passwords[session_key]

        result = self.generate_ai_command(user_input, username, model)

        if "error" in result:
            return f"❌ **AI Generation Failed:** {result['error']}\n\n💡 Try direct command: `$ your-command`"

        command = result["command"]
        confidence = result.get("confidence", "medium")
        explanation = result.get("explanation", "")
        safety = result.get("safety", "caution")
        requires_sudo = result.get("requires_sudo", False)

        confidence_icon = (
            "🎯" if confidence == "high" else "⚠️" if confidence == "medium" else "❓"
        )
        safety_icon = "✅" if safety == "safe" else "⚠️" if safety == "caution" else "🚨"

        # Add sudo prefix if required for execution
        execute_command = f"sudo {command}" if requires_sudo else command

        response = f"""🤖 **AI Command for {name}**

**Request:** {user_input}

**Generated Command:**
```bash
{command}
```

**Analysis:**
{confidence_icon} **Confidence:** {confidence.title()}
{safety_icon} **Safety:** {safety.title()}
{"🔐 **Requires:** sudo privileges" if requires_sudo else "👤 **Requires:** user privileges"}

**Explanation:** {explanation}
"""

        # Auto-execute high confidence safe commands
        if (
            confidence == "high"
            and safety == "safe"
            and self.valves.AUTO_EXECUTE_HIGH_CONFIDENCE
        ):
            response += "\n⚡ **Auto-executing...**\n\n"

            exec_result = self.execute_ssh_command(
                server_info, execute_command, password
            )

            # Handle interactive prompts in auto-execution
            if exec_result.get("interaction_required"):
                self.last_interactive_command[server_id] = execute_command
                response += f"""⌨️ **Auto-execution paused - Interactive Input Required**

**Current Output:**
```
{exec_result['output']}
```

**Hint:** {exec_result['prompt_hint']}

**How to respond:** `!YOUR_RESPONSE_HERE`"""
                return response

            # Normal auto-execution completion
            self.save_command_history(
                server_id,
                execute_command,
                True,
                confidence,
                exec_result["success"],
                exec_result.get("output", ""),
            )

            if exec_result["success"]:
                response += "✅ **Execution Result:**\n"
                if exec_result["output"]:
                    output = exec_result["output"]
                    if len(output) > 1000:
                        output = output[:1000] + "\n... (truncated)"
                    response += f"```\n{output}\n```"
                else:
                    response += "Command executed successfully"
            else:
                response += "❌ **Execution Failed:**\n"
                if exec_result["error"]:
                    response += f"```\n{exec_result['error']}\n```"
        else:
            response += f"\n💡 **To Execute:** `$ {execute_command}`\n🔧 **Or enable auto-execution in settings**"

        return response

    def __del__(self):
        """Cleanup when pipe is destroyed"""
        try:
            self.cleanup_all_sessions()
            self.thread_pool.shutdown(wait=False)
        except:
            pass
